var documenterSearchIndex = {"docs":
[{"location":"example2/","page":"Predator prey","title":"Predator prey","text":"EditURL = \"https://github.com/kavir1698/EvoDynamics.jl/blob/master/examples/example2.jl\"","category":"page"},{"location":"example2/#Predator-prey","page":"Predator prey","title":"Predator prey","text":"","category":"section"},{"location":"example2/","page":"Predator prey","title":"Predator prey","text":"Here we create a predator prey model of two species, one haploid and one diploid.","category":"page"},{"location":"example2/","page":"Predator prey","title":"Predator prey","text":"using EvoDynamics\nusing Plots","category":"page"},{"location":"example2/","page":"Predator prey","title":"Predator prey","text":"Model parameters are in a .jl file as follows:","category":"page"},{"location":"example2/","page":"Predator prey","title":"Predator prey","text":"generations = 14\nspace = (2, 2)\n\n## 1. Species parameters\n\nspecies1 = Dict(\n  :name => \"a\",\n  :number_of_genes => 7,\n  :number_of_phenotypes => 4,\n  :abiotic_phenotypes => [1],\n  :biotic_phenotypes => [2, 3],\n  :migration_phenotype => 4,\n  :migration_threshold => 1.5,\n  :vision_radius => 1,\n  :check_fraction => 0.5,\n  :ploidy => 2,\n  :epistasis_matrix => [\n    1.0 0.43 -0.41 0.38 0.48 -0.43 -0.1 -0.08 -0.09 -0.5 0.41 0.44 -0.21 -0.12\n    0.34 1.0 -0.19 -0.36 0.38 -0.28 0.24 -0.22 0.12 0.12 -0.12 -0.39 0.21 0.26\n    0.05 0.27 1.0 0.04 0.01 -0.14 0.3 -0.28 0.43 -0.13 0.2 -0.02 0.25 -0.39\n    -0.12 0.33 -0.48 1.0 -0.4 -0.48 -0.22 -0.36 -0.24 -0.07 -0.12 -0.49 -0.37 0.27\n    0.25 0.25 -0.14 0.49 1.0 0.28 -0.34 -0.49 0.45 -0.14 0.26 -0.13 -0.44 -0.17\n    -0.47 0.19 -0.24 0.41 0.08 1.0 0.11 0.03 0.15 0.49 0.04 0.41 -0.19 0.13\n    0.37 0.09 -0.11 0.4 0.42 0.45 1.0 -0.01 -0.47 0.07 0.5 0.44 -0.18 -0.2\n    -0.32 0.15 0.4 -0.24 -0.21 0.5 0.22 1.0 -0.33 0.48 -0.49 0.07 0.5 -0.07\n    0.02 -0.16 0.33 0.48 -0.42 0.39 0.2 -0.11 1.0 0.46 -0.06 0.22 -0.3 0.31\n    0.41 -0.18 -0.16 -0.4 0.01 0.04 0.07 0.2 -0.37 1.0 -0.33 0.49 0.05 -0.42\n    0.03 0.25 0.14 -0.36 0.28 -0.18 0.09 -0.2 0.46 -0.48 1.0 -0.21 0.41 -0.46\n    0.0 0.44 -0.34 -0.42 0.37 -0.04 0.43 -0.25 0.21 0.19 0.29 1.0 -0.02 0.06\n    0.46 -0.1 0.14 -0.22 -0.26 0.13 -0.5 -0.41 -0.31 0.0 -0.15 0.29 1.0 0.17\n    -0.22 0.21 0.46 -0.01 -0.35 -0.11 0.25 -0.03 0.18 -0.38 -0.4 -0.28 0.05 1.0],\n  :pleiotropy_matrix => Bool[\n    1 1 0 0 0 0 0 1 0 1 0 1 0 1\n    1 0 1 1 1 0 1 1 1 0 0 1 1 0\n    1 0 1 0 1 0 0 0 0 0 1 0 1 0\n    0 0 0 0 1 0 0 1 1 1 1 0 1 0],\n  :growth_rate => 2.8,\n  :expression_array => [0.28878032859775615, 0.4629421231828499, 0.26092147517051467, 0.952859489607121, 0.9638502824424, 0.05038142018016245, 0.05930756376654234, 0.033459292878885716, 0.32421526342800044, 0.9029235877297073, 0.7670060809312949, 0.12766808941531993, 0.8656895869985795, 0.342191940658253],\n  :selection_coefficient => 0.1,\n  :phenotype_contribution_to_fitness => nothing,\n  :mutation_probabilities => [0.9, 0.0, 0.0],\n  :mutation_magnitudes => [0.05, 0.0, 0.01],\n  :N => [1000, 0, 0, 0],\n  :environmental_noise => 0.01,\n  :optimal_phenotypes => [fill([1.4 for p in 1:1], space...) for t in 0:generations],\n  :bottlenecks => [fill(0.0, space...) for t in 0:generations],\n  :age => 5,\n  :recombination => 1,\n  :initial_energy => 1,\n  :reproduction_start_age => 2,\n  :reproduction_end_age => 5,\n  :abiotic_variance => 1.0,\n  :biotic_variance => 1.0,\n  :mating_scheme => 0\n)\n\nspecies2 = Dict(\n  :name => \"b\",\n  :number_of_genes => 8,\n  :number_of_phenotypes => 5,\n  :abiotic_phenotypes => [1, 2],\n  :biotic_phenotypes => [3, 4],\n  :migration_phenotype => 5,\n  :migration_threshold => 1.4,\n  :vision_radius => 1,\n  :check_fraction => 0.5,\n  :ploidy => 1,\n  :epistasis_matrix => [\n    1.0 -0.01 -0.01 -0.34 -0.42 0.18 -0.09 0.13\n    0.28 1.0 -0.21 -0.11 0.12 -0.46 0.21 -0.39\n    0.0 0.28 1.0 0.1 0.09 0.3 0.1 0.17\n    0.0 -0.42 0.05 1.0 -0.11 -0.07 -0.27 0.43\n    0.31 0.47 -0.42 -0.34 1.0 -0.4 0.16 0.11\n    -0.19 0.29 -0.33 -0.49 0.17 1.0 -0.1 -0.28\n    -0.43 0.38 -0.06 0.39 0.21 -0.5 1.0 -0.08\n    0.26 0.27 -0.44 -0.08 0.47 -0.27 -0.27 1.0],\n  :pleiotropy_matrix => Bool[\n    1 0 0 0 1 1 0 0\n    1 0 0 1 1 0 1 1\n    0 1 1 1 1 1 0 1\n    1 0 1 0 0 1 0 1\n    1 1 0 1 1 1 1 1],\n  :growth_rate => 1.5,\n  :expression_array => [0.24923147816626035, 0.7155732641738595, 0.9655184311211502, 0.8638149724268844, 0.5075272565823061, 0.9189652626508431, 0.7897640036022151, 0.17091233765481717],\n  :selection_coefficient => 0.1,\n  :phenotype_contribution_to_fitness => nothing,\n  :mutation_probabilities => [0.9, 0.0, 0.0],\n  :mutation_magnitudes => [0.05, 0.0, 0.01],\n  :N => [100, 0, 0, 0],\n  :environmental_noise => 0.01,\n  :optimal_phenotypes => [fill([1.4, 1.6], space...) for t in 0:generations],\n  :bottlenecks => [fill(0.0, space...) for t in 0:generations],\n  :age => 3,\n  :recombination => 0,\n  :initial_energy => 0,\n  :reproduction_start_age => 1,\n  :reproduction_end_age => 3,\n  :abiotic_variance => 1.0,\n  :biotic_variance => 2.0,\n  :mating_scheme => 0\n)\n\n## 2. Model parameters\n\n#NB this dictionary should be called model_parameters\nmodel_parameters = Dict(\n  :species => [species1, species2],\n  :generations => generations,\n  :space => space,\n  :metric => \"chebyshev\",\n  :periodic => false,\n\n  :resources => [\n    [2000 2200\n     1830 1900] for i in 0:generations],\n\n  :interactions => [0.0 1.0\n                    1.0 0.0],\n\n  :food_sources => [1.0 0.0\n                    1.0 0.0],\n\n  :seed => nothing\n)","category":"page"},{"location":"example2/","page":"Predator prey","title":"Predator prey","text":"param_file = \"../examples/paramfile2.jl\"  #hide\nagentdata, modeldata, model = runmodel(param_file);\nnothing #hide","category":"page"},{"location":"example2/","page":"Predator prey","title":"Predator prey","text":"By default, runmodel uses the following functions for data collection: mean_fitness_per_species, species_N. They collect the mean fitness and the population size of each species per time step. This is just a sample data. You can collect any kind of data from the model by writing your own data collection function (see Collecting data).","category":"page"},{"location":"example2/","page":"Predator prey","title":"Predator prey","text":"plot(1:size(modeldata, 1), getindex.(modeldata[:, 3], 1), xlabel=\"Time\", ylabel=\"N\", label=\"Prey\")\nplot!(1:size(modeldata, 1), getindex.(modeldata[:, 3], 2), label=\"Predator\")","category":"page"},{"location":"example2/","page":"Predator prey","title":"Predator prey","text":"","category":"page"},{"location":"example2/","page":"Predator prey","title":"Predator prey","text":"This page was generated using Literate.jl.","category":"page"},{"location":"model_description/#Model-Parameters-and-Simulation-Outline","page":"Model Parameters and Simulation Outline","title":"Model Parameters and Simulation Outline","text":"","category":"section"},{"location":"model_description/#Parameters","page":"Model Parameters and Simulation Outline","title":"Parameters","text":"","category":"section"},{"location":"model_description/","page":"Model Parameters and Simulation Outline","title":"Model Parameters and Simulation Outline","text":"All model parameters are stored in a Julia (.jl) file and divided into two sections: species-specific parameters and model-specific parameters. Parameters for each species and the model are written in separate Dict objects, with keys represented as Symbols (using a colon : before the names).","category":"page"},{"location":"model_description/","page":"Model Parameters and Simulation Outline","title":"Model Parameters and Simulation Outline","text":"To parameterize a model, you can copy an existing set of parameters from the Examples section and modify them accordingly.","category":"page"},{"location":"model_description/#.-Species-specific-parameters","page":"Model Parameters and Simulation Outline","title":"1. Species specific parameters","text":"","category":"section"},{"location":"model_description/","page":"Model Parameters and Simulation Outline","title":"Model Parameters and Simulation Outline","text":"Each species should have a dictionary object containing the following parameters. The order in which they are written does not matter.","category":"page"},{"location":"model_description/","page":"Model Parameters and Simulation Outline","title":"Model Parameters and Simulation Outline","text":"name: A String representing the name of the species.\nnumber_of_genes: An integer indicating the number of genes that the species has.\nploidy: Either 1 for haploid or 2 for diploid genomes. Diploids may undergo recombination.\nnumber_of_phenotypes: An integer indicating the number of phenotypes that the species has.\nabiotic_phenotypes: An array of integers specifying abiotic phenotypes among all phenotypes. Abiotic phenotypes determine how the species interacts with the environment.\nbiotic_phenotypes: An array of integers specifying biotic phenotypes among all phenotypes. Biotic phenotypes determine how the species interacts with other individuals from the same or different species.\nmigration_phenotype: An integer specifying the phenotype that corresponds to the migration trait. If the species does not migrate, put 0.\nmigration_threshold: The phenotypic value of the migration phenotype after which an individual can migrate.\nvision_radius: A number determining the radius of neighboring sites that the agent can see before migration.\ncheck_fraction: A floating-point number between 0 and 1 representing the fraction of visible sites that the agent can check and decide whether to migrate to.\nepistasis_matrix: An epistasis matrix of size l x l, where l is the product of the number of genes and ploidy. The epistasis matrix specifies the direction (positive or negative) and size of the effect of one locus on other loci. For example, if at row 1 and column 2 is a value 0.2, it means that locus 1 affects locus 2 by increasing the effect of locus 2 (because its positive) with 20% of the effect of locus 1.\npleiotropy_matrix: A binary matrix (0s and 1s) with size number of phenotypes x l. The pleiotropy matrix specifies the phenotypes that each locus affects.\nexpression_array: A vector of size l representing the expression amount of each locus determining its effect size.\ngrowth_rate: The mean of a Poisson distribution for the number of offspring per reproduction. This number is fully realized when the fitness of a haploid individual is 1 or the distance between the biotic phenotypes of two diploid individuals is 0. Otherwise, the actual growth rate is a fraction of this value.\nselection_coefficient: A number between 0 and 1 that determines the importance of fitness. 0 represents a model without selection. To specify time-variable selection coefficient, provide a vector with a length equal to the number of generations plus 1 (to account for generation zero).\nphenotype_contribution_to_fitness: The relative contribution of each abiotic phenotype to fitness. This parameter can be nothing to denote equal contribution of all abiotic phenotypes, or it can be a vector of numbers with as many elements as there are abiotic phenotypes.\nmutation_probabilities: A vector of three numbers each of which specifies the probability for a different type of mutations: mutation probability of the expression\\array, _pleiotropy\\matrix, and _epistasis\\matrix_, respectively.\nmutation_magnitudes: A vector of numbers with the same size as mutation\\probabilities_ that determines the magnitude of mutation for each of the three categories. Specifically, the numbers represent the variances of normal distributions with mean 0 for the expression array and epistasis matrices, and the probability of changing a 0 and 1 in the pleiotropy matrix. When mutating an offspring, it first checks whether there will be a mutation (mutation\\probabilities), and if positive, a mutation with a magnitude determined by _mutation\\magnitudes_ occurs.\nN: A vector of integers representing the initial number of individuals at each site.\nenvironmental_noise: A number for the variance of a normal distribution with mean 0 that will be added to the phenotypes.\noptimal_phenotypes: A vector of matrices representing the optimal phenotypes at each time step. Each matrix represents the optimal phenotypes for each site in space. The optimal phenotype at each site is a vector as long as the abiotic_phenotypes. The vector is as long as the number of model steps (generations) plus 1 (for time zero).\nage: An integer for the maximum age of individuals of this species.\nreproduction_start_age: The age at which individuals can reproduce.\nreproduction_end_age: The age after which individuals cannot reproduce.\nrecombination: The mean of a Poisson distribution for the number of crossing overs per sexual reproduction.\ninitial_energy: A parameter for parental care of infants. Values greater than 0 indicate that newly born individuals can survive for a certain number of time steps without requiring food from the environment or other species. The consumption rate is always constant for all species at one unit per time step. Use with caution as having an initial energy larger than zero can lead to infinite population growth when individuals without food reproduce and their offspring also reproduce without food. For example, this happens when start age of reproduction is 1 and initial energy is larger than 0.\nbottlenecks: A vector of matrices, each of which has the same size as the space and contains the probability of death at each site. The vector is as long as the number of model steps (generations) plus 1 (for time zero). Use this if you want to impose a killing event in the model at specific times and places. Otherwise, use 0.0 for all the values in the matrices.\nmating_scheme: One of the following: -1, 0, 1. Only used in sexual reproduction. Zero means randomly paired couples are likely to have as many offspring as any other pair. Their phenotypes do not affect their reproductive success. -1 represents disassortative mating, where the more different the phenotypes of the pair, the more children they have. 1 represents assortative mating, where individuals with similar phenotypes are more likely to reproduce.\nabiotic_variance: The variance of a normal distribution used in determining the phenotypic distance of agents to the optimal environmental phenotypes. The larger the variance, the less important is the distance.\nbiotic_variance: The variance of a normal distribution used in determining the biotic phenotypic distance between two individuals (used in any kind of interaction). Larger values mean that all pairs are equally likely to interact, regardless of their phenotype difference.","category":"page"},{"location":"model_description/#.-Model-parameters","page":"Model Parameters and Simulation Outline","title":"2. Model parameters","text":"","category":"section"},{"location":"model_description/","page":"Model Parameters and Simulation Outline","title":"Model Parameters and Simulation Outline","text":"This dictionary should be named \"model_parameters\".","category":"page"},{"location":"model_description/","page":"Model Parameters and Simulation Outline","title":"Model Parameters and Simulation Outline","text":"species: A vector containing the dictionaries of the species.\ngenerations: An integer indicating the number of steps the model will run.\nspace:A tuple of two integers (e.g., (3,2)) determining the size of space. If you do not want any spatial structure, use (1,1).\nmetric: Either \"chebyshev\" or \"euclidean\". Determines how many neighbors a space site has. \"chebyshev\" metric means that the r-neighborhood of a position includes all positions within the hypercube with a side length of 2 * floor(r) and centered at the origin position. \"euclidean\" metric means that the r-neighborhood of a position includes all positions whose Cartesian indices have Euclidean distance ≤ r from the Cartesian index of the given position.\nperiodic: A Boolean value (true or false) determining whether the boundaries of the space are connected or not.\nresources: A vector of matrices where each matrix has the size of the space and determines the amount of resources per site. The vector is as long as the number of model steps (generations) plus 1 (for time zero).\ninteractions: A species-species interaction matrix of floating-point numbers determining how individuals from different species interact. Each value represents the strength of interaction (between 0 and 1). The sign (+/-) indicates the direction of interaction, where a positive value means similar individuals interact more strongly, and a negative value means dissimilar individuals tend to interact more.\nfood_sources: A species-species food matrix of floating-point numbers determining what each species feeds on (consumption rate). Non-zero values on the diagonal indicate that the food resource is from the environment. Off-diagonal values indicate that a species (in the rows) feeds on another species (in the columns). Numbers can be zero or any positive number. The magnitude of the number determines how much energy the predator gains by eating the prey. All species use 1 unit of energy per time step.\nseed: Either an integer or nothing for a random number.","category":"page"},{"location":"model_description/#Simulation-outline","page":"Model Parameters and Simulation Outline","title":"Simulation outline","text":"","category":"section"},{"location":"model_description/","page":"Model Parameters and Simulation Outline","title":"Model Parameters and Simulation Outline","text":"The simulations are fully agent-based, meaning that agents do not receive any model-level knowledge about what happens to them. The following steps occur in order for agents that are activated in a random order:","category":"page"},{"location":"model_description/","page":"Model Parameters and Simulation Outline","title":"Model Parameters and Simulation Outline","text":"Grow one step older.\nMigrate.\nBurn energy.\nEat from the environment if the species can.\nInteract with other individuals.\nReproduce.\nSurvive. Agents die if they are too old, or do not have enough energy, or by chance given its fitness.\nKill agents with a probability given in bottlenecks.","category":"page"},{"location":"model_description/#Migration","page":"Model Parameters and Simulation Outline","title":"Migration","text":"","category":"section"},{"location":"model_description/","page":"Model Parameters and Simulation Outline","title":"Model Parameters and Simulation Outline","text":"If a species has the capability to migrate (i.e., migration\\_phenotype is not 0), then at each time step, it is checked whether the phenotypic value of the migration phenotype is above the migration\\_threshold. If it is, then the agent checks a random check\\_fraction of the neighboring sites and moves to the most suitable site. Suitability is calculated by comparing the agent's abiotic phenotype and the optimal abiotic phenotypic value for each site. If the checked neighbors have worse conditions than the current site, the agent does not move.","category":"page"},{"location":"model_description/#Burn-energy","page":"Model Parameters and Simulation Outline","title":"Burn energy","text":"","category":"section"},{"location":"model_description/","page":"Model Parameters and Simulation Outline","title":"Model Parameters and Simulation Outline","text":"Agent's energy is reduced by one unit.","category":"page"},{"location":"model_description/#Eat","page":"Model Parameters and Simulation Outline","title":"Eat","text":"","category":"section"},{"location":"model_description/","page":"Model Parameters and Simulation Outline","title":"Model Parameters and Simulation Outline","text":"If the agent is able to eat from the environment (the diagonal of food\\_sources at the corresponding row and column is non-zero) and there are any environmental resources left at the agent's site, its energy level is boosted by the value in the corresponding element at food\\_sources.","category":"page"},{"location":"model_description/#Interacting-with-other-individuals","page":"Model Parameters and Simulation Outline","title":"Interacting with other individuals","text":"","category":"section"},{"location":"model_description/","page":"Model Parameters and Simulation Outline","title":"Model Parameters and Simulation Outline","text":"At each time step, the agent interacts with individuals from each species in the model. If there are fewer agents at the site than the number of species, the agent interacts with all of them. Otherwise, it interacts with at most one randomly chosen individual from each species. If most of the individuals at the site are from the first species, then the agent is more likely to interact with an individual from the first species and with no individual from the second species. This setup allows interactions between species to depend on the population size of the species at each site.","category":"page"},{"location":"model_description/","page":"Model Parameters and Simulation Outline","title":"Model Parameters and Simulation Outline","text":"For each pair of interacting individuals, it is first checked whether one individual feeds on the other. If so, the hunt is successful with a probability proportional to the average phenotypic distance between the biotic phenotypes of the two individuals.","category":"page"},{"location":"model_description/","page":"Model Parameters and Simulation Outline","title":"Model Parameters and Simulation Outline","text":"The phenotypic distance between two species depends on the sign of the corresponding element in the interactions matrix. If it is negative, the hunt is more successful when the average phenotype of the two individuals is more different.","category":"page"},{"location":"model_description/","page":"Model Parameters and Simulation Outline","title":"Model Parameters and Simulation Outline","text":"The phenotypic distance between two individuals is calculated as the average distance between all pairs of biotic phenotypes between the two individuals. The distance between two phenotypic values is determined using the formula:","category":"page"},{"location":"model_description/","page":"Model Parameters and Simulation Outline","title":"Model Parameters and Simulation Outline","text":"$ | 0.5 - \\text{cdf}(\\text{Normal}(\\text{ph1},  1), \\text{ph2})| $","category":"page"},{"location":"model_description/","page":"Model Parameters and Simulation Outline","title":"Model Parameters and Simulation Outline","text":"where cdf is the cumulative density function, Normal is a normal distribution with mean ph1 (phenotypic value 1) and variance 1, and ph2 is phenotypic value 2.","category":"page"},{"location":"model_description/","page":"Model Parameters and Simulation Outline","title":"Model Parameters and Simulation Outline","text":"If the two individuals are not predator-prey and they are from the same species but different sexes, and both are in reproductive age, they are marked to reproduce in the next stage. Otherwise, if they are from different species and the two species interact with each other (the corresponding values in the interactions matrix are non-zero), they interact with each other. If the individual from species 1 to species 2 has a positive value in the interactions matrix, it increases the fitness of the individual from species 2. If the element is zero, it does not affect the fitness of the individual from species 2. And if the element is negative, it decreases the fitness of the individual from species 2. Similarly, the individual from species 2 can affect the fitness of the individual from species 1. The two interactions do not need to be symmetric. The magnitude of change in fitness due to interaction is determined by the phenotypic distance between the two individuals and the interaction value in the interactions matrix.","category":"page"},{"location":"model_description/#Reproduction","page":"Model Parameters and Simulation Outline","title":"Reproduction","text":"","category":"section"},{"location":"model_description/","page":"Model Parameters and Simulation Outline","title":"Model Parameters and Simulation Outline","text":"If an individual is haploid and in reproductive age, it reproduces an identical offspring to itself, except that the expression array, pleiotropy matrix, and the epistasis matrix of the offspring will mutate based on the probabilities and magnitudes in the mutation\\_probabilities and mutation\\_magnitudes matrices. The number of offspring is a random number from a Poisson distribution with a mean equal to the species' growth rate times the fitness of the individual.","category":"page"},{"location":"model_description/","page":"Model Parameters and Simulation Outline","title":"Model Parameters and Simulation Outline","text":"If two diploid individuals mate to reproduce, their reproductive success is proportional to their phenotypic distance (depending on mating\\_scheme). The number of offspring is a random number from a Poisson distribution with a mean equal to the reproductive success of the two individuals times the growth rate of the species.","category":"page"},{"location":"model_description/","page":"Model Parameters and Simulation Outline","title":"Model Parameters and Simulation Outline","text":"Each offspring of diploid individuals inherits a gamete from each parent. A gamete is half of the expression array, pleiotropy matrix, and epistasis matrix. If recombination is allowed (value > 0), then the gametes undergo crossing over. The number of crossing overs is a random number from a Poisson distribution with a mean equal to the recombination parameter.","category":"page"},{"location":"model_description/#Survival","page":"Model Parameters and Simulation Outline","title":"Survival","text":"","category":"section"},{"location":"model_description/","page":"Model Parameters and Simulation Outline","title":"Model Parameters and Simulation Outline","text":"At each step, the agent may die due to several factors. First, it dies if it has negative energy (has not been able to eat enough). Second, it dies if it is too old (greater than the maximum age). Third, it dies with a probability negatively correlated to its fitness. This probability is adjusted by the selection\\_coefficient. If the selection coefficient is zero, then the individual does not die. If it is one, the fitness determines a 100% survival rate.","category":"page"},{"location":"model_description/#Fitness","page":"Model Parameters and Simulation Outline","title":"Fitness","text":"","category":"section"},{"location":"model_description/","page":"Model Parameters and Simulation Outline","title":"Model Parameters and Simulation Outline","text":"The fitness of individuals is determined by their abiotic fitness, i.e., their abiotic phenotypic distance to the optimal phenotypes in the environment. Thus, their fitness can vary at different sites.","category":"page"},{"location":"model_description/#Mutation","page":"Model Parameters and Simulation Outline","title":"Mutation","text":"","category":"section"},{"location":"model_description/","page":"Model Parameters and Simulation Outline","title":"Model Parameters and Simulation Outline","text":"Mutation can occur at three levels: changing the expression of each gene, changing the pleiotropy matrix, and changing the epistasis interactions between genes. The probability that a mutation occurs at each of these levels is controlled by the mutation\\_probabilities parameter. The size of mutations, when they occur, is controlled by the mutation\\_magnitudes parameter, which represents the variances of normal distributions. A mutation in the gene expression and epistasis matrix is carried out by adding a random number from a normal distribution to the existing values. The pleiotropy matrix is mutated by switching 0s and 1s with the probability given in the third element of mutation\\_magnitudes.","category":"page"},{"location":"example1/","page":"Simple Wright-Fisher","title":"Simple Wright-Fisher","text":"EditURL = \"https://github.com/kavir1698/EvoDynamics.jl/blob/master/examples/example1.jl\"","category":"page"},{"location":"example1/#Simple-Wright-Fisher","page":"Simple Wright-Fisher","title":"Simple Wright-Fisher","text":"","category":"section"},{"location":"example1/","page":"Simple Wright-Fisher","title":"Simple Wright-Fisher","text":"We can create and run simple Wright-Fisher simulations with EvoDynamics.jl. To that end, we define a single haploid species, in an unstructured space, with two single genes affecting biotic and abiotic traits, respectively.","category":"page"},{"location":"example1/","page":"Simple Wright-Fisher","title":"Simple Wright-Fisher","text":"using EvoDynamics","category":"page"},{"location":"example1/","page":"Simple Wright-Fisher","title":"Simple Wright-Fisher","text":"A simple one-species model with no spatial structure. Model parameters are in a .jl file as follows:","category":"page"},{"location":"example1/","page":"Simple Wright-Fisher","title":"Simple Wright-Fisher","text":"generations = 20\nspace = (1, 1)\n\n## 1. Species parameters\n\nspecies1 = Dict(\n  :name => \"a\",\n  :number_of_genes => 2,\n  :number_of_phenotypes => 2,\n  :abiotic_phenotypes => [1],\n  :biotic_phenotypes => [2],\n  :migration_phenotype => 0,\n  :migration_threshold => 3.5,\n  :vision_radius => 0,\n  :check_fraction => 0.0,\n  :ploidy => 1,\n  :epistasis_matrix => [1.0 0.0; 0.0 1.0],\n  :pleiotropy_matrix => Bool[1 0; 0 1],\n  :growth_rate => 1.0,\n  :expression_array => [0.28, 0.46],\n  :selection_coefficient => 0.1,\n:phenotype_contribution_to_fitness => nothing,\n  :mutation_probabilities => [0.9, 0.0, 0.0],\n  :mutation_magnitudes => [0.05, 0.0, 0.0],\n  :N => [100],\n  :environmental_noise => 0.01,\n  :optimal_phenotypes => [fill([1.5 for p in 1:1], space...) for t in 0:generations],\n  :bottlenecks => [fill(0.0, space...) for t in 0:generations],\n  :age => 2,\n  :recombination => 0,\n  :initial_energy => 0,\n  :reproduction_start_age => 1,\n  :reproduction_end_age => 2,\n  :abiotic_variance => 1.0,\n  :biotic_variance => 1.0,\n  :mating_scheme => 1\n)\n\n## 2. Model parameters\n\n#NB this dict should be called model_parameters\nmodel_parameters = Dict(\n  :species => [species1],\n  :generations => generations,\n  :space => space,\n  :metric => \"chebyshev\",\n  :periodic => false,\n  :resources => [fill(200, 1, 1) for i in 0:generations],\n  :interactions => [-0.1],\n  :food_sources => [1.0],\n  :seed => nothing\n)","category":"page"},{"location":"example1/","page":"Simple Wright-Fisher","title":"Simple Wright-Fisher","text":"param_file = \"../examples/paramfile1.jl\"\n\nagentdata, modeldata = runmodel(param_file);\nnothing #hide","category":"page"},{"location":"example1/","page":"Simple Wright-Fisher","title":"Simple Wright-Fisher","text":"By default, runmodel uses the following functions for data collection: mean_fitness_per_species, species_N. They collect the mean fitness and the population size of each species per time step. This is just a sample data. You can collect any kind of data from the model by writing your own data collection function (see Collecting data).","category":"page"},{"location":"example1/","page":"Simple Wright-Fisher","title":"Simple Wright-Fisher","text":"modeldata","category":"page"},{"location":"example1/","page":"Simple Wright-Fisher","title":"Simple Wright-Fisher","text":"","category":"page"},{"location":"example1/","page":"Simple Wright-Fisher","title":"Simple Wright-Fisher","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#EvoDynamics.jl-Documentation","page":"Introduction","title":"EvoDynamics.jl Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Welcome to the documentation of EvoDynamics.jl, a powerful framework designed to explore and understand the dynamics of biological systems across multiple scales. EvoDynamics.jl offers a comprehensive set of tools and models to study evolutionary and ecological processes, providing a bridge between genotypes, phenotypes, and their intricate interactions with the environment and other species. By incorporating eco-evolutionary feedbacks, EvoDynamics.jl allows for the investigation of rapidly evolving populations that continuously adapt to changing conditions, particularly in antagonistic interactions, competitive scenarios, and mutualistic relationships.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"With EvoDynamics.jl, you can delve into various biological levels, ranging from single genes affecting individual phenotypes to population dynamics and species interactions. The framework features an explicit genotype-phenotype architecture, capturing the complexity of pleiotropy and epistasis, selection acting on multiple phenotypes, differential fitness contributions, arbitrary spatial structures, migration, and interactions among species. Whether you are interested in modeling complex food webs, understanding the emergence of cooperation, or studying the interplay between genetic variation and ecological dynamics, EvoDynamics.jl provides a versatile platform for exploring the intricacies of biological systems.","category":"page"},{"location":"#Biological-Levels-Controlled-by-the-Model","page":"Introduction","title":"Biological Levels Controlled by the Model","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"EvoDynamics.jl enables the study of interactions at different biological levels, allowing researchers to investigate various aspects of evolutionary and ecological dynamics. The package provides capabilities to model the following levels:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Genes and Phenotypes: EvoDynamics.jl allows modeling the relationships between genes and phenotypes, including the effects of single genes on single phenotypes, gene interactions, pleiotropy, and epistasis.\nPopulation Dynamics: The framework enables modeling population dynamics, including population growth, selection acting on multiple phenotypes, differential fitness contributions, mutation, recombination, and time-variable selection strength.\nSpecies Interactions: EvoDynamics.jl allows for modeling interactions between species, such as competition, predation, mutualism, and parasitism. It provides the flexibility to model complex food webs with various asymmetrical interactions.\nSpatial Structure: The package supports a grid-based spatial structure, enabling the modeling of individual migration and spatially explicit interactions between individuals and species.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Fig. 1. __Model Structure illustrating different biological levels controlled by EvoDynamics.jl.__)","category":"page"},{"location":"#Features","page":"Introduction","title":"Features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"EvoDynamics.jl offers a wide range of features that make it a powerful tool for studying ecological and evolutionary dynamics. Some of the key features include:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Complex Food Web Modeling: The package allows for the modeling of complex food webs with various asymmetrical interactions between species.\nPhenotype-Based Interactions: Individuals interact with each other and the environment based on their phenotypes, allowing for realistic ecological dynamics.\nGenotype-Phenotype Mapping: EvoDynamics.jl provides the ability to connect genome structure to phenotypes and populations, allowing for the investigation of genotype-phenotype relationships.\nSpatial Modeling: The package supports a grid-based spatial structure, enabling the modeling of individual migration and spatially explicit interactions.\nDynamic Environment: EvoDynamics.jl allows for the modeling of a complex environment with spatio-temporally varying resources, providing a realistic setting for ecological interactions.\nOptimal Phenotypic Values: Researchers can incorporate time-varying optimal phenotypic values per site and per species, allowing for the study of phenotypic adaptation to changing environmental conditions.\nDifferential Fitness Contributions: The framework supports the differential contributions of traits to fitness, allowing for the investigation of trait-dependent selection.\nSelective Removal: EvoDynamics.jl provides the ability to remove individuals at specific times and locations, allowing for the modeling of selective pressures and perturbations in the system.\nHaploid and Diploid Species: The package supports modeling both haploid and diploid species, providing flexibility in representing different reproductive modes.\nMutation and Recombination: EvoDynamics.jl incorporates mutation and recombination mechanisms, allowing for the simulation of genetic variation and evolution.\nData Collection and Analysis: The package offers easy data collection and analysis, allowing researchers to collect and analyze simulation results efficiently.\nParallel Computing: Researchers can run replicates in parallel, leveraging the computational power of multiple processors for increased efficiency.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For detailed information on how to use EvoDynamics.jl and its various functionalities, please refer to the Tutorial and Model Parameters and Simulation Outline sections.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#Installation","page":"Tutorial","title":"Installation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Install using the following command in a Julia REPL.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"]add EvoDynamics","category":"page"},{"location":"tutorial/#Basic-usage","page":"Tutorial","title":"Basic usage","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Parameters of a model should be put in a julia file (.jl format) with the structure below.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"See Simple Wright-Fisher and Predator prey for complete examples of parameter files.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"## 1. Functions\n...\n\n## 2. Species parameters. A dictionary for each species\n\n## 3. Model parameters as a dictionary.\n","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The order of these sections is important because each section relies on objects from its preceding sections.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Functions are used to create parameters that may change temporally and spatially. The following parameters are functions: bottleneck function, which kills specific agents at certain times and locations; optimal phenotype values, which returns the optimal phenotype for a species at a given time and location; and environmental resources that may change over time.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You may create as many species as you want. Parameters of each species are stored in a dictionary.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Model parameters is a dictionary that stores general parameters of the model, such as the number of generations, space size, and species interaction parameters.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"First, define your model parameters (here, we call it parameters.jl) Simple Wright-Fisher and Predator prey have examples of initiation parameters. See Model Parameters and Simulation Outline for a description of each parameter.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can use the runmodel function to create a model from these parameters and run the simulation.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"runmodel","category":"page"},{"location":"tutorial/#EvoDynamics.runmodel","page":"Tutorial","title":"EvoDynamics.runmodel","text":"runmodel(param_file::AbstractString; kwargs)\n\nCreates and runs a model given parameters. Returns a DataFrame of collected data, which are specified by kwargs.\n\nKeywords\n\nadata=[] agent data to be collected. Either agent fields or functions that accept an agent as input can be put in the array. To aggregate collected data, provide tuples inside the array. For example, to collect mean and median fitness of individuals which is in field W, your array will be [(:W,mean), (:W,median)].\nmdata=[meanfitnessperspecies, speciesN] model data to be collected. By default, collects mean population fitness per species. Each row of the output DataFrame corresponds to all agents and each column is the value function applied to a field. The functions in the array are applied to the model object.\nwhen=nothing The generations from which data are collected. By default collect at all steps.\nreplicates::Int = 0 Number of replicates per simulation.\nparallel::Bool = false Whether to run replicates in parallel. If true, you should add processors to your julia session (e.g. by addprocs(n)) and define your parameters and EvoDynamics on all workers. To do that, add @everywhere before them. For example, @everywhere EvoDynamics.\nseeds = optionally, provide an array of integers as seeds for each replicate.\nagentstep=EvoDynamics.agent_step! Define your own agent stepping if you wish to change the sequence of events or change any one event.\nmodelstep=EvoDynamics.model_step!\nshowprogress::Bool = false Whether to show a progress meter of the simulations.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using EvoDynamics\nagentdata, modeldata, model = runmodel(\"parameters.jl\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Within runmodel, before the parameters are used for constructing and ABM object, they are checked for correctness in type and shape using the load_parameters function.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"load_parameters","category":"page"},{"location":"tutorial/#EvoDynamics.load_parameters","page":"Tutorial","title":"EvoDynamics.load_parameters","text":"load_parameters(paramfile::String)\n\nReads the parameters from a parameter file (.jl), checks them for correct format, and returns the model_parameters dictionary object. See the online docs for the list of parameters and their correct values.\n\nThe output of this function can be loaded to the model_initiation function to create an ABM object. A user would normally not need to do these steps directly, because they are handled by the runmodel function. These will be useful for debugging and running the model in a different way.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"And then, using the model_initiation function, an agent-based model (ABM) is constructed.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"model_initiation","category":"page"},{"location":"tutorial/#EvoDynamics.model_initiation","page":"Tutorial","title":"EvoDynamics.model_initiation","text":"model_initiation(dd)\n\nInnitializes the model and returns an ABM object that includes all the initial agents. The input of the function is a dictionary returned by the load_parameters function.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Having and ABM object and parameters that define the run conditions, the runmodel function uses run! or ensemblerun! functions from the Agents.jl package to run the model and collect data.","category":"page"},{"location":"tutorial/#Creating-simulation-parameter-files","page":"Tutorial","title":"Creating simulation parameter files","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"EvoDynamics.jl reads simulation parameters (Model Parameters and Simulation Outline) from a julia file containing dictionaries and functions. This file can be populated manually using a text editor or from within a Julia session.","category":"page"},{"location":"tutorial/#Collecting-data","page":"Tutorial","title":"Collecting data","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The interface to the model is from the runmodel function (see Tutorial).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"EvoDynamics.jl uses Agents.jl underneath. See Agents.jl's documentation for details about writing functions to collect any data during simulations. Here, we explain the specific implementation of the model.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There are two main objects from which you can collect data: and agent object of type AbstractAgent and a model object of type ABM. Both of these types are defined the Agents.jl package.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Agent object has the following fields that are individual specific: id, pos, species, epistasisMat (epistasis matrix), pleiotropyMat (pleiotropy matrix), q (gene expression array), biotic_phenotype, abiotic_phenotype, age, sex, energy, interaction_history, and W (fitness).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The model object has the following fields that can be accessed with the . syntax and describe properties of species or the model: ngenes, nphenotypes, growthrates, selectionCoeffs, ploidy, optvals (optimal values), optinds (optval indices per generation), mutProbs (mutation probabilities), mutMagnitudes (mutation magnitudes), N, E (environmental noise), generations, nspecies, migration_traits, vision_radius, check_fraction, migration_thresholds, step, biotic_phenotypes (indices of biotic phenotypes per species), abiotic_phenotypes, max_ages, food_sources, interactions, resources, recombination, initial_energy.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can collect data from agents and/or from the model object. To collect data from agents, use the adata keyword argument in the runmodel function, and to collect data from the model, use the mdata keyword. A complete description of the values these keywords take are at data collection section of the Agents.jl package.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For example, we use the function below to count the number of individual per species:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"\"Returns the size of each species.\"\nfunction species_N(model::ABM)\n  allagents = model.agents\n  if length(allagents) == 0\n    return fill(0, model.nspecies)\n  else\n    counts = countmap([a.species for a in values(model.agents)])\n    output = fill(0, model.nspecies)\n    for (k, v) in counts\n      output[k] = v\n    end\n    return output\n  end\nend\n\nusing EvoDynamics\n\nagentdata, modeldata, model = runmodel(\"parameters.yml\", mdata=[species_N])","category":"page"},{"location":"tutorial/#Running-simulations-in-parallel","page":"Tutorial","title":"Running simulations in parallel","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can run replicate simulation in parallel. To that end, you need to add processors, and import EvoDynamics.jl and your parameters files on all cores:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Distributed\naddprocs(4)\n@everywhere using EvoDynamics\n@everywhere param_file = \"params.jl\"\n@everywhere EvoDynamics.load_parameters(param_file)\nadata, mdata, models = runmodel(param_file, replicates=10, parallel=true)","category":"page"},{"location":"tutorial/#Modifying-the-sequence-of-events-and-specific-functions","page":"Tutorial","title":"Modifying the sequence of events and specific functions","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If you want to change the sequence of events within each time-step, you can do so by providing your own stepping function to the runmodel function. With this flexibility, you can also keep the sequence as it is, but change one specific event within the sequence by using a different function for it. A good staring point would be to copy the agent_step! function from the package (at src/simulation.jl).","category":"page"}]
}

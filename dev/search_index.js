var documenterSearchIndex = {"docs":
[{"location":"api/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"example2/#","page":"Example 2","title":"Example 2","text":"EditURL = \"https://github.com/kavir1698/EvoDynamics.jl/blob/master/examples/example2.jl\"","category":"page"},{"location":"example2/#Dummy-example-2-1","page":"Example 2","title":"Dummy example 2","text":"","category":"section"},{"location":"example2/#","page":"Example 2","title":"Example 2","text":"b = 2","category":"page"},{"location":"example2/#","page":"Example 2","title":"Example 2","text":"","category":"page"},{"location":"example2/#","page":"Example 2","title":"Example 2","text":"This page was generated using Literate.jl.","category":"page"},{"location":"example1/#","page":"Example 1","title":"Example 1","text":"EditURL = \"https://github.com/kavir1698/EvoDynamics.jl/blob/master/examples/example1.jl\"","category":"page"},{"location":"example1/#Dummy-example-1","page":"Example 1","title":"Dummy example","text":"","category":"section"},{"location":"example1/#","page":"Example 1","title":"Example 1","text":"a = 2","category":"page"},{"location":"example1/#","page":"Example 1","title":"Example 1","text":"","category":"page"},{"location":"example1/#","page":"Example 1","title":"Example 1","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#EvoDynamics.jl-Documentation-1","page":"Introduction","title":"EvoDynamics.jl Documentation","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"For usage, see Tutorial.","category":"page"},{"location":"#Theory-1","page":"Introduction","title":"Theory","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Effect of trait arquitecture on biodiversity.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Coupling pleiotropy and covariance matrices to explore their effect on biodiversity.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"This paper describes the theoretical foundation of this project.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Melo, D., & Marroig, G. (2015). Directional selection can drive the evolution of modularity in complex traits. Proceedings of the National Academy of Sciences, 112(2), 470–475. https://doi.org/10.1073/pnas.1322632112","category":"page"},{"location":"#Methods-1","page":"Introduction","title":"Methods","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The model parameters and their role in the simulations:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"m loci.\np traits.\ny<sub>i</sub> with i from 1 to 2m. It is representative of the m loci for a diploid individual.\nx<sub>i</sub> with i from 1 to p. It represents the additive effects of y<sub>i</sub>.\nx = B'y. If B<sub>ij</sub>=1, locus y<sub>i</sub> influences additive effect x<sub>j</sub>.\nz<sub>i</sub> = By<sub>i</sub> + ε = x<sub>i</sub> + ε. This is the phenotypic variance of individual i. ε is environmental deviation taken from a normal distribution with a uniform variance V<sub>e</sub>=0.8.\nThere are two mutation rates:\nμ per locus per generation where y<sub>i</sub> changes from a normal distribution with mean 0 and σ=0.02.\nμ<sub>B</sub> per generation per entry to flip entry values of the B matrix of each individual. Each position of the B matrix is independent.\nW(z): selection = e<sup>(-1/2 ((z-θ)<sup>T</sup> ω<sup>-1</sup> (z-θ)))</sup>\nθ: multivariate fitness optimum. The rate of change of θ represents different strengths of directional selection.\nω: covariance matrix of the selection surface.\nReproduction:\nRandomly select parents with replacement proportional to their fitness.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"2. One offspring per couple.\n3. Offspring is created from gametes that include one allele from each loci and the corresponding row of the B matrix.\n4. N<sub>e</sub> constant at 5k.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Initial parameter values from Jones et al. (15-17)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"<!– ","category":"page"},{"location":"#Problems-and-solutions-1","page":"Introduction","title":"Problems and solutions","text":"","category":"section"},{"location":"#Problem-1","page":"Introduction","title":"Problem","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The mean fitness of populations either goes to zero or becomes too large (infinite). Here are some possible solutions:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Limit the upper bound of the fitness of each individual.\nHave different fitness functions for when there are negative values in the ω matrices and when they are all positive\nLimit the θ optimal values within y ranges.\nDo no use inverse of the covariance matrix. Use a matrix that always has ones on the diagonal and non-positives on the off-diagonals.","category":"page"},{"location":"#Potential-solution-1","page":"Introduction","title":"Potential solution","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Transform each distribution T to N(0,1)\nSet maximum total distance to optimum Z*std(T) where Z = diagonal values cov matrix (Z=10)\nSet fitness surface covariance mat Diag == 10; random graph from U(0,1) U(0,-1); modular U(0,1) U(0,-1)\nNormalize fitness values sum(sum(w)) to have a max of 1 –>","category":"page"},{"location":"tutorial/#Tutorial-1","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#EvoDynamics.jl's-basic-usage-1","page":"Tutorial","title":"EvoDynamics.jl's basic usage","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"First, define your model parameters. Here is a set of random parameters:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using Random\nimport LinearAlgebra: Symmetric\n\nP = (4, 5)  # a tuple  specifying the number of traits p for each species\nL = (7, 8)  # a tuple  specifying the number of loci l for each species\nm = (2, 1)  # ploidy for each species.\nparameters = Dict(\n  :L => L .* m,\n  :P => P,\n  :R => (0.8, 0.12),  # growth rate per species\n  :C => rand(-0.1:0.01:0.1, 2, 2),  # competition coefficient matrix. It denotes the strength of competition exerted by an individual of species j on an individual of species i. \n  :B =>  Tuple([Random.bitrand(i[1], i[2]) for i in zip(P, L .* m)]),  # a tuple  of pleiotropy matrices, one for each species. Each matrix consists of zeros and ones only. make sure no rows are all zero (a trait is not controled :by any locus)\n  :γ => (-0.5, -0.5), # a tuple  of selection coefficients for each species\n  :m => m,\n  :T => Tuple([randn(Float16, n) for n in P]), # a tuple  of arrays, each inner array θ specifying optimal phenotypes for each species\n  :Ω => Tuple([Symmetric(rand(Float16, i[1], i[2])) for i in zip(P, P)]), # a tuple  of matrices, each of which ω represents a covariance matrix of the selection surface\n  :M => (0.02, 0.02), # a tuple of mutation rates μ for each species\n  :MB => (0.05, 0.05), # a tuple of mutation rates μ of B for each species\n  :N => Dict(1 => (1000, 1000)), # a dictionary where a key is node number and the value is a tuple for population size of each species at that node\n  :K => Dict(1 => [1000, 1000], 2 => [1000, 1000], 3 => [1000, 1000], 4 => [1000, 1000]), # a dictionary where a key is node number and a value is tuple for carrying capacity of the node for each species.\n  :migration_rates => [1.0 0.02 0.02 0.02; 0.03 1.0 0.03 0.03; 0.01 0.01 1.0 0.01; 0.01 0.01 0.01 1.0],  # a matrix of migration rates between each pair of nodes. The rows and columns of the matrix are node numbers in order.\n  :Y => Tuple([rand(Float16, i) for i in L .* m]), # a tuple  of Arrays, each specifying the initial y vector of each species\n  :E => (0.8, 0.8), # a tuple  of the variance of a normal distribution ε representing environmental noise for each species.\n  :generations => 5, # number of generations to run the simulation\n  :space => (2,2),  # Either a tuple for a grid size or a SimpleGraph\n  :moore => false\n)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"We can the use the runmodel function to create a model from these parameters and run the simulation.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"EvoDynamics.runmodel","category":"page"},{"location":"tutorial/#EvoDynamics.runmodel","page":"Tutorial","title":"EvoDynamics.runmodel","text":"runmodel(parameters::Dict; kwargs)\n\nCreates and runs a model given parameters. Returns a DataFrame of collected data, which are specified by kwargs.\n\nKeywords\n\ncollect::Dict=Dict(:model => [meanfitnessper_species]) Data to be collected. By default, collects mean population fitness per species.\nwhen::AbstractArray{Int}=1:parameters[:generations] The generations from which data are collected\nreplicates::Int = 0 Number of replicates per simulation.\nparallel::Bool = false Whether to run replicates in parallel. If true, you should add processors to your julia session (e.g. by addprocs(n)) and define your parameters and EvoDynamics on all workers. To do that, add @everywhere before them. For example, @everywhere EvoDynamics.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"using EvoDynamics\ndata = runmodel(parameters)\ndata[1:5, :]","category":"page"}]
}
